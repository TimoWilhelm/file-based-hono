import { readdirSync, statSync, writeFileSync, existsSync, mkdirSync } from "node:fs";
import { join, relative, dirname } from "node:path";

const ROUTES_DIR = join(process.cwd(), "src/routes");
const OUTPUT_FILE = join(process.cwd(), "src/generated/routes.ts");

interface RouteFile {
  filePath: string;
  routePath: string;
}

function scanRoutes(dir: string, routes: RouteFile[] = []): RouteFile[] {
  if (!existsSync(dir)) {
    console.log(`Routes directory not found: ${dir}`);
    return routes;
  }

  const entries = readdirSync(dir);

  for (const entry of entries) {
    const fullPath = join(dir, entry);
    const stat = statSync(fullPath);

    if (stat.isDirectory()) {
      scanRoutes(fullPath, routes);
    } else if (entry.endsWith(".ts") && !entry.endsWith(".test.ts")) {
      const relativePath = relative(ROUTES_DIR, fullPath);
      let routePath = "/" + relativePath.replace(/\.ts$/, "").replace(/\\/g, "/");

      // Handle index files: /users/index -> /users
      if (routePath.endsWith("/index")) {
        routePath = routePath.slice(0, -6) || "/";
      }

      // Handle dynamic segments: [id] -> :id
      routePath = routePath.replace(/\[([^\]]+)\]/g, ":$1");

      routes.push({ filePath: fullPath, routePath });
    }
  }

  return routes;
}

function generateManifest(routes: RouteFile[]): string {
  const imports: string[] = [];
  const entries: string[] = [];

  routes.forEach((route, index) => {
    const importPath = relative(dirname(OUTPUT_FILE), route.filePath)
      .replace(/\.ts$/, "")
      .replace(/\\/g, "/");

    const importName = `route${index}`;
    imports.push(`import * as ${importName} from "${importPath.startsWith(".") ? importPath : "./" + importPath}";`);
    entries.push(`  "${route.routePath}": ${importName},`);
  });

  return `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generate-routes.ts

${imports.join("\n")}

export type RouteModule = {
  GET?: (c: any) => Response | Promise<Response>;
  POST?: (c: any) => Response | Promise<Response>;
  PUT?: (c: any) => Response | Promise<Response>;
  PATCH?: (c: any) => Response | Promise<Response>;
  DELETE?: (c: any) => Response | Promise<Response>;
  default?: any;
};

export const routes: Record<string, RouteModule> = {
${entries.join("\n")}
};
`;
}

function sortRoutesBySpecificity(routes: RouteFile[]): RouteFile[] {
  return routes.sort((a, b) => {
    const aDynamic = (a.routePath.match(/:/g) || []).length;
    const bDynamic = (b.routePath.match(/:/g) || []).length;
    if (aDynamic !== bDynamic) return aDynamic - bDynamic;
    return b.routePath.length - a.routePath.length;
  });
}

function main() {
  const routes = sortRoutesBySpecificity(scanRoutes(ROUTES_DIR));

  if (routes.length === 0) {
    console.log("No routes found. Creating empty manifest.");
  } else {
    console.log(`Found ${routes.length} route(s):`);
    routes.forEach((r) => console.log(`  ${r.routePath} -> ${relative(process.cwd(), r.filePath)}`));
  }

  const outputDir = dirname(OUTPUT_FILE);
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  writeFileSync(OUTPUT_FILE, generateManifest(routes));
  console.log(`\nGenerated: ${relative(process.cwd(), OUTPUT_FILE)}`);
}

main();
